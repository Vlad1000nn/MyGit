*pip install numpy* — качаем numpy
*import numpy as np* — импортируем numpy
*a = np.array([1,2,3])* - создать массив ndarray
*a.shape* — указывает размерность
*a = numpy.zeros((3,5))* — делает массив из нулей размером 3 на 5
*a = numpy.ones((3,5))* — делает массив из единиц размером 3 на 5
*a = np.eye(5)* — делает единичную матрицу размером 5 на 5
*a = numpy.empty((3,2))* — создает матрицу 3 на 2 с мусорными значениями
*np.transpose(a)* — возвращает транспонированную матрицу
*a = np.arange(20,30,5)* — последовательность от 20 до 29 с шагом 5
*np.set_printoptions(threshold=10000, precision=2)* — настраивает вывод: выводит до 10000 чисел с 2 знаками после запятой


# Сложение векторов
*a = np.array([20,30,40,50])*
*b = np.arange(4)*
*c = a + b*
*c — array([20,31,42,53])*

# Вычитание векторов
*c = a - b*
*c — array([20,29,38,47])*

# Умножение векторов
*c = a * b*
*c — array([0,30,80,150])*

# Деление векторов
*c = a / b*
*c — array([inf,30.0,])

_В numpy есть inf и nan_

# Тригонометрия
np.cos(a)
np.sin(a)
np.tan(a)
np.arcsin(a) (или np.asin(a))
np.arccos(a) (или np.acos(a))
np.arctan(a) (или np.atan(a))

# Гиперболические функции
np.sinh(a)
np.cosh(a)
np.tanh(a)

# Округления
*np.round(5.256, 2)* — округление до заданного числа после запятой (если .5 до ближайшего чётного)
*np.ceil(5.256)* — округление до большего целого
*np.floor(5.256)* — округление до меньшего целого
*np.fix(5.256)* — до ближайшего целого к нулю

# Агрегирующие функции
пусть есть _a = np.array([[1,2,3], [4,5,6]])_
*np.sum(a)* — 21, сумма всех элементов
*a.sum()* — другой способ того же самого
*a.min()*
*a.max()*
По умолчанию применяется к массиву будто он список, можно указать ось axis
*a.min(axis=1)* — array([1,4])
*a.min(axis=0)* — array([1,2,3])

# Срезы
_a = np.arange(10) ** 3_
_array([0,1,8,27,64,125,216,343,512,729])_

*a[3:5]* — array([27,64])

*a[3:5] = 2*
_array([0,1,8,2,2,125,216,343,512,729])_

# Индексы

_b = np.array([[ 0,  1,  2,  3],_
              _[10, 11, 12, 13],_
              _[20, 21, 22, 23],_
              _[30, 31, 32, 33],_
              _[40, 41, 42, 43]])_

*b[2,3]*
*b[(2,3)]*

*b[[2,3],3]* — берём строки 2,3 и вытаскиваем оттуда 3 элемент
_array([23,33])_

*b[[2,3],[2,3]]* — берём строку 2 столбец 2, строку 3 столбец 3
_array([22, 33])_

*b[:,2]* — вернёт третий столбец
_array([ 2, 12, 22, 32, 42])_
*b[: 2]* — первая и вторая строка
_array([[ 0,  1,  2,  3],_
       _[10, 11, 12, 13]])_

*b[2:3][0]* — вернёт третью строку(так как изначально обёртка массив в массиве)
_array([20,21,22,23])_

*e=np.ones((2,3,4,2,3,4))*
*e[...,2]* — скипаем предыдущие индексы все


*for el in a.flat* — делает обход массива а будто он одномернный
*a.flatten* — создаёт именно копию объекта
*a.ravel()* — делает массив плоским(массив не меняется)

*a.shape = (6,2)* — можно менять размерность массива, сам массив не меняется
*a.reshape((3,4))* — то же самое
*a.transpose()* — транспонирует(не меняет сам массив)


# Объединение  и разбиение массивов
hstack() — объединяет массивы горизонтально
vstack() — объединяет массивы вертикально

_a = np.array([[1,2],_
              _[3,4]])_

_b = np.array([[5,6],_
              _[7,8]])_

*np.vstack((a,b))* (или np.row_stack((a,b)))
_array([[1, 2],_
       _[3, 4],_
       _[5, 6],_
       _[7, 8]])_

*np.hstack((a,b))* (или np.culumn_stack((a,b)))
_array([[1, 2, 5, 6],_
       _[3, 4, 7, 8]])_

hsplit() — разбивает массив по горизонтальной оси(указываем либо количество массивов одинаковой формы, либо номера столбцов по которым разрез идёт)
_a = np.arange(12).reshape((2, 6))_
_array([[ 0,  1,  2,  3,  4,  5],_
       _[ 6,  7,  8,  9, 10, 11]])_

*z1,z2,z3 = np.hsplit(a,3)* — разбили а на 3 равные части
_z1 = array([[0,1],_
            _[6,7])_
_z2 = array([[2,3],_
            _[8,9])_
_z3 = array([[4,5],_
            _[10,11])_

*np.hsplit(a, (3,4))* — Разрезать a после третьего и четвёртого столбца
_[array([[0,1,2],_
        _[6,7,8]]),_
 _array([[3],_
        _[9]]),_
 _array([[4,5],_
        _[10,11]])]_

*np.vsplit(a,2)*
_[array([[0,1,2,3,4,5]]),_
 _array([[6,7,8,9,10,11]])]_

# Копии и представления


